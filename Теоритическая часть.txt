1. С его помощью возможно:
Вертикальное выравнивание блока внутри родителя.
Оформления всех детей контейнера так, чтобы они распределили между собой доступную ширину/высоту, независимо от того, 
сколько ширины/высоты доступно.
Сделать все колонки в макете одинаковой высоты, даже если наполнение в них различно.

2. display: table - динамическое вертикальное выравнивание по центру.
С его помощью можно получить выравнивание по вертикали элементов с динамической высотой.

3. Для центрирования инлайновых элементов – достаточно поставить родителю text-align: center:

<style>
  .outer {
    text-align: center;
    border: 1px solid blue;
  }
</style>

<div class="outer">Текст</div>

Блок по горизонтали центрируется margin: auto:

<style>
  .outer {
    border: 1px solid blue;
  }
  .inner {
    width: 100px;
    border: 1px solid red;
    margin: auto;
  }
</style>

<div class="outer">
  <div class="inner">Текст</div>
</div>

Flexbox - самый простой и современный способ горизонтального выравнивания по центру. 
Для родителя добавляются два флексовых свойства.

 <div class="wrap flexbox">
    <div class="block"></div>
</div>

.flexbox {     display: flex;
    justify-content: center;
  }

4. Первая ось называется главной (по умолчанию она направлена слева направо). 
Вторая - поперечная (по умолчанию направлена сверху вниз), она всегда перпендикулярно главной. 
Главная ось задаёт основное направление flex-элементов во flex-контейнере, а поперечная ось определяет 
их направление при переносе на новую линию.

Направление главной оси можно изменить, осуществляется это с помощью CSS-свойства flex-direction.
Значения wrap и wrap-reverse CSS-свойства flex-wrap определяют направление поперечной оси.

Свойства flex-direction и flex-wrap можно указать с помощью универсального CSS свойства flex-flow.

5. В разметке flexbox присутствует конкретный вариант использования, в котором, возможно, 
понадобится атрибут justify-self. Например, когда будет необходимо разделить набор flex элементов для создания 
отдельного шаблона навигации. В таком случае, можно использовать атрибут margin со значением auto. 
Атрибут с таким значением будет занимать все доступное пространство в своём измерении. Так работает центрирование 
блока со свойством margin:auto. Установив значение атрибутов margin-left и margin-right в значение auto, обе стороны 
нашего блока попытаются занять все доступное пространство и, таким образом, заставят двигаться блок в центр.
Установив значение атрибутаmargin в auto для одного элемента в наборе с flex-элементами, выровненных с начала, 
можно создать разделённую навигацию. Это хорошо работает с разметкой flexbox и свойствами выравнивания. 
Как только для элемента со свойством margin: auto не остаётся свободного места, он станет вести себя также, как и все 
остальные flex элементы, и сократится в объёме, пытаясь уместиться в доступное пространство.

.box {
  display: flex;
}
.push {
    margin-left: auto;
}
<div class="box">
  <div>One</div>
  <div>Two</div>
  <div>Three</div>
  <div class="push">Four</div>
  <div>Five</div>
</div>

6. box-sizing
Применяется для изменения алгоритма расчёта ширины и высоты элемента.
Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border.
Аналогично обстоит и с высотой блока. Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height 
задавали размеры не содержимого, а размеры блока.

7. flex-shrink : определяет, как flex-элемент будет уменьшаться относительно других flex-элементов во flex-контейнере 
flex-grow : определяет, как flex-элемент будет увеличиваться относительно других flex-элементов во flex-контейнере

8. 
 justify-content: space-between;  
/* флекс элементы равномерно распределяются по всей строке, при этом первый флекс элемент позиционируются в начале контейнера,
 а последний флекс элемент позиционируется в конце контейнера */

9. ширина = 134.545 + 5 + 1.989 = 141,534
   высота = 11.818 + 2 + 1.989 = 15.807

10. Свойство order задает порядок следования отдельно взятого flex-блока внутри flex-контейнера. 
Применяется к конкретному flex блоку.
Своим значением свойство принимает положительное или отрицательное целое число. 
Чем меньше число - тем раньше будет стоять элемент, независимо от расположения в HTML коде 
относительно других элементов.

11. 
<body>
    <table border="1" style="width:50%">
        <tr>
            <td>Columu 1</td>
            <td>Columu 2</td>
            <td>Colomu 3</td>
        </tr>
        <tr>
            <td rowspan="2">Row 1 Cell 1</td>
            <td>Row 1 Cell 2</td>
            <td>Row 1 Cell 3</td>
        </tr>
        <tr>
            <td>Row 2 Cell 2</td>
            <td>Row 2 Cell 3</td>
        </tr>
        <tr>
            <td colspan="3">Row 3 Cell 1</td>
        </tr>
    </table>
</body>

12.Для фиксированного позиционирования характерны следующие особенности.

При прокрутке веб-страницы элемент остаётся на своём исходном месте.
Положение элемента всегда отсчитывается от области просмотра браузера, независимо от позиционирования 
родителя.
При выходе элемента за пределы видимой области справа или снизу от неё, не возникает полос прокрутки и 
элемент просто «обрезается».
Применяется такой тип позиционирования для создания меню, вкладок, заголовков, в общем, 
любых элементов, которые должны быть закреплены на веб-странице и всегда видны посетителю. 

13.Лучше всего верстать большие блоки текста при помощи float.

14. По умолчанию flex-элементы во flex-контейнере занимают всю его высоту.
Значение `flex` или `inline-flex` определяет то, как **flex-контейнер** будет представлен на странице. 
Если его необходимо отобразить в виде **блока**, то используйте значение `flex`. 
Если элемент необходимо представить как **строку**, то используйте значение `inline-flex`. 
В этом случае он будет занимать столько места странице, сколько необходимо для отображения его элементов.





